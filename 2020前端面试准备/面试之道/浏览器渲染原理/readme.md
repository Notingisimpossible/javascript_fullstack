# 浏览器渲染原理

  - 渲染引擎
    1. 火狐： Gecko,
    2. 谷歌、safari: webkit
  
  1. 浏览器接收到html文件并转换为 DOM 树
  - 当数据转化字符串以后，浏览器会先将这些字符串通过词法分析转换为标记，这个过程称之为标记化
  字节数据 ===》 字符串 ===》 Token(标记，构成代码的最小单位)
  当标记化结束后，这些标记会紧接着转化为Node,最后这些node会根据不同的node之前的联系构建成一颗DOM树
  2. 浏览器将css文件转换为 cssOM 树
    - 这个过程中，浏览器会确定每一个节点的样式是什么，这个过程很消耗资源。因为样式可以自行设置，也可以继承。所以这个过程得递归 cssom树，然后确定具体的元素到底是什么样式

  3. 生成渲染树
    - DOM树 + CSSOM树，但不是简单的合并，渲染树只会包含需要显示的节点和节点的样式信息，如果节点是display:none;的，就不会在渲染树中显示

  4. 渲染
    - 根据渲染树来布局(回流)，调用GPU绘制，合成图层显示在屏幕上。

  # 为什么操作 DOM 慢？
    - js直接操作dom，这涉及到两块内容，js是靠js引擎来执行的，而操作dom是靠渲染引擎来执行的，所以这个操作势必会带来两个线程之间的通信，也就一定会开销二位的性能。操作的dom一多，也就等同于一直进行线程之间的通信。
    2. 操作dom会造成重绘和回流的情况，也就导致了性能的开销

  # 插入几万个dom,如何实现页面不卡顿？
    1. 解决这个问题的重点应该是想如何分批次渲染部分DOM，使用requestAnimationFrame的方式循环插入dom.
    2. 另一种实现方式-虚拟滚动：只渲染可视区域，非可视区域完全不渲染，当用户滚动的时候去替换渲染的内容

  # 什么情况下会阻塞渲染？
    1. html和css会阻塞渲染，所以我们应该降低一开始需要渲染的文件的大小，并且扁平层级，优化选择器。
    2. script标签的解析会导致暂停DOM的构建，解析完成之后才会继续构建DOM,所以想要首屏渲染越快，越不能在首屏加载js，这也是为什么script标签要尽量放在底部的原因。(当script加上了defer这个属性时，就会默认把js放在html解析完成之后执行，所以放哪儿都可以)
    3. 对于没有任何依赖的ja文件，我们可以加上async属性，表示js文件下载和解析时异步的不会阻塞渲染

  # 重绘和回流
    - 重绘：
      - 节点需要改变外观而不影响布局，比如改变color就叫重绘
    - 回流：
      - 布局或者几何属性需要改变
    - 回流必定会引起重绘，重绘不一定会引起回流

    - 以下几个动作会导致性能问题
      1. 改变window大小
      2. 改变字体大小
      3. 添加或删除样式
      4. 文字大小改变

    - 你不知道的是：回流和重绘其实和EventLoop有关
      1. EventLoop执行完微任务之后，会判断 document 是否需要更新，因为浏览器是60HZ的刷新率，每16.6毫秒会更新一次
      2. 然后判断是否有resize或者scroll事件，有的话就会触发事件，所以resize和scroll事件也是至少16毫秒才会触发一次，
      3. 判断是否触发了media query
      4. 更新动画发送事件
      5. 判断是否全屏
      6. 执行requestAnimationFrame回调
      7. 执行 IntersectionObserver回调， 该方法用于判断该元素是否可见
      8. 更新页面

      - 以上就是一帧中可能会干的事情
    
    # 减少重绘和回流
    1. demo1.html
    2. 尽量不要用table布局table中很小的改变就会造成整个table的重新布局